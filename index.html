<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>SpeedReader</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect width='64' height='64' rx='12' fill='%230b0f14'/><text x='4' y='46' font-family='system-ui,sans-serif' font-weight='900' font-size='42'><tspan fill='%23ff3b3b'>S</tspan><tspan fill='%23e7eef8'>R</tspan></text></svg>">

<!-- ============================================================
     GOOGLE ADSENSE — STEP-BY-STEP SETUP
     ============================================================
     1. Go to https://adsense.google.com and sign in / sign up.
     2. Add your site URL and wait for approval (days → weeks).
     3. Once approved, copy your Publisher ID (looks like: ca-pub-1234567890123456).
     4. Replace EVERY occurrence of "ca-pub-3128443998439992" in this
        file with your real Publisher ID.
     5. Each <ins class="adsbygoogle"> block is one ad unit.  After
        approval, you can also replace the data-ad-slot values with
        specific ad-unit IDs from your AdSense dashboard for finer
        control (optional — the auto-ads script handles it too).
     6. The async AdSense script below loads Google's ad code.
        It is safe to leave it in even before approval; it simply
        won't serve ads until your account is active.
     ============================================================ -->

<!-- Google AdSense script — replace ca-pub-3128443998439992 with your real ID -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3128443998439992"
  crossorigin="anonymous"></script>

<style>
  :root{
    --bg:#0b0f14;
    --panel:#111827;
    --panel2:#0f1624;
    --text:#e7eef8;
    --muted:#9bb0c9;
    --border:rgba(255,255,255,0.14);
    --border2:rgba(255,255,255,0.20);
    --red:#ff3b3b;
  }

  *,*::before,*::after{box-sizing:border-box;}

  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    display:flex;
    flex-direction:column;
    align-items:center;
    min-height:100vh;
    padding:0;
  }

  /* ── Ad banner containers ── */
  .ad-banner{
    width:100%;
    overflow:hidden;
    background:rgba(17,24,39,0.60);
    border-bottom:1px solid var(--border);
    position:relative;
    min-height:100px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .ad-banner.bottom{
    border-bottom:none;
    border-top:1px solid var(--border);
    margin-top:auto;
  }

  /* Placeholder shown before AdSense is live */
  .ad-placeholder{
    color:var(--muted);
    font-size:12px;
    text-align:center;
    padding:8px 16px;
    opacity:0.6;
  }

  /* Scrolling wrapper for the ad marquee effect */
  .ad-scroll{
    display:flex;
    animation: adScroll 30s linear infinite;
    white-space:nowrap;
  }
  .ad-scroll:hover{ animation-play-state:paused; }

  @keyframes adScroll{
    0%  { transform:translateX(0); }
    100%{ transform:translateX(-50%); }
  }

  .ad-scroll-item{
    flex:0 0 auto;
    padding:0 40px;
    display:flex;
    align-items:center;
    justify-content:center;
    min-width:300px;
  }

  /* ── Main app ── */
  .app{
    width: 940px;
    max-width: 96%;
    background: linear-gradient(180deg, rgba(17,24,39,0.92), rgba(17,24,39,0.78));
    border:1px solid var(--border);
    border-radius:18px;
    padding:16px;
    margin:18px 0;
  }

  /* ── Navigation tabs ── */
  .nav{
    display:flex;
    gap:4px;
    margin-bottom:14px;
    background:rgba(0,0,0,0.25);
    border-radius:12px;
    padding:4px;
  }
  .nav-tab{
    flex:1;
    height:42px;
    border:none;
    border-radius:10px;
    background:transparent;
    color:var(--muted);
    font-size:15px;
    font-weight:700;
    cursor:pointer;
    transition:background 0.2s, color 0.2s;
    line-height:42px;
    padding:0;
  }
  .nav-tab:hover{
    color:var(--text);
    border:none;
  }
  .nav-tab.active{
    background:rgba(255,255,255,0.10);
    color:var(--text);
    border:none;
  }

  /* ── Page visibility ── */
  .page{ display:none; }
  .page.active{ display:block; }

  /* ── Shared controls ── */
  .top{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
    flex-wrap:wrap;
    margin-bottom:12px;
  }

  .brand{
    font-weight:800;
    letter-spacing:0.2px;
    font-size:14px;
    user-select:none;
  }
  .brand .red{ color:var(--red); }

  .controls{
    display:flex;
    align-items:center;
    gap:10px;
    flex-wrap:wrap;
  }

  .speed{
    display:flex;
    gap:8px;
    align-items:center;
  }

  button{
    height:40px;
    border-radius:12px;
    padding:0 12px;
    border:1px solid var(--border);
    background:rgba(255,255,255,0.06);
    color:var(--text);
    cursor:pointer;
    font-size:14px;
    line-height:40px;
    user-select:none;
  }

  button:hover{ border-color: rgba(255,255,255,0.28); }
  button:disabled{ opacity:0.45; cursor:not-allowed; }

  .speed button.active{
    background:rgba(255,255,255,0.14);
    border-color:rgba(255,255,255,0.26);
  }

  .primary{
    background: rgba(255,59,59,0.12);
    border-color: rgba(255,59,59,0.30);
  }

  .drop{
    border:2px dashed var(--border2);
    border-radius:14px;
    padding:18px;
    text-align:center;
    cursor:pointer;
    background: rgba(0,0,0,0.10);
  }

  .drop .t{
    font-weight:750;
    color:var(--text);
  }
  .drop .s{
    margin-top:6px;
    font-size:13px;
    color:var(--muted);
  }
  .drop .fn{
    margin-top:8px;
    font-size:12px;
    color:var(--muted);
    word-break:break-word;
  }

  .reader{
    margin-top:14px;
    height: 280px;
    border-radius:14px;
    background: rgba(0,0,0,0.25);
    border:1px solid rgba(255,255,255,0.10);
    display:grid;
    place-items:center;
    position:relative;
    overflow:hidden;
  }

  .guide{
    position:absolute;
    width:2px;
    height:150px;
    background:rgba(255,255,255,0.14);
    border-radius:999px;
  }

  .word{
    font-size: clamp(40px, 6vw, 74px);
    font-weight: 850;
    white-space: nowrap;
    letter-spacing: 0.3px;
    padding: 0 10px;
    user-select:none;
  }

  .orp{ color: var(--red); }

  .status{
    margin-top:10px;
    color:var(--muted);
    font-size:12px;
    display:flex;
    justify-content:space-between;
    gap:10px;
    flex-wrap:wrap;
  }

  input[type="file"]{ display:none; }

  /* ── VoiceReader styles ── */
  .vr-settings{
    display:flex;
    gap:12px;
    flex-wrap:wrap;
    align-items:end;
    margin-top:14px;
  }

  .vr-field{
    display:flex;
    flex-direction:column;
    gap:4px;
    flex:1;
    min-width:160px;
  }

  .vr-field label{
    font-size:12px;
    color:var(--muted);
    font-weight:600;
  }

  .vr-field select{
    height:40px;
    border-radius:12px;
    padding:0 10px;
    border:1px solid var(--border);
    background:rgba(255,255,255,0.06);
    color:var(--text);
    font-size:14px;
    cursor:pointer;
    appearance:auto;
  }

  .vr-field select option{
    background:#1a2233;
    color:var(--text);
  }

  .vr-controls{
    display:flex;
    gap:8px;
    margin-top:14px;
    flex-wrap:wrap;
  }

  .vr-text-area{
    margin-top:14px;
    min-height:200px;
    max-height:400px;
    border-radius:14px;
    background: rgba(0,0,0,0.25);
    border:1px solid rgba(255,255,255,0.10);
    padding:16px;
    overflow-y:auto;
    font-size:15px;
    line-height:1.7;
    color:var(--text);
  }

  .vr-text-area .spoken{
    color:var(--muted);
  }
  .vr-text-area .current-word{
    color:var(--red);
    font-weight:700;
  }

  .vr-text-area .empty-msg{
    color:var(--muted);
    font-style:italic;
  }

  .vr-progress{
    margin-top:10px;
    display:flex;
    align-items:center;
    gap:10px;
    color:var(--muted);
    font-size:12px;
  }

  .vr-progress-bar{
    flex:1;
    height:6px;
    border-radius:3px;
    background:rgba(255,255,255,0.08);
    overflow:hidden;
  }

  .vr-progress-fill{
    height:100%;
    background:var(--red);
    border-radius:3px;
    transition:width 0.3s;
    width:0%;
  }
</style>
</head>

<body>

  <!-- ═══ TOP AD BANNER ═══ -->
  <div class="ad-banner top">
    <!-- AdSense responsive ad unit (top) -->
    <ins class="adsbygoogle"
      style="display:block;width:100%;min-height:90px"
      data-ad-client="ca-pub-3128443998439992"
      data-ad-slot="TOP_AD_SLOT_ID"
      data-ad-format="horizontal"
      data-full-width-responsive="true"></ins>
    <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>

    <!-- Placeholder shown when ads aren't loaded yet -->
    <div class="ad-placeholder" id="adPlaceholderTop">
      <div class="ad-scroll">
        <div class="ad-scroll-item">Ad Space — Google AdSense</div>
        <div class="ad-scroll-item">Your ad could appear here</div>
        <div class="ad-scroll-item">Ads will appear here once your AdSense account is approved</div>
        <div class="ad-scroll-item">Ad Space — Google AdSense</div>
        <div class="ad-scroll-item">Your ad could appear here</div>
        <div class="ad-scroll-item">Ads will appear here once your AdSense account is approved</div>
      </div>
    </div>
  </div>

  <!-- ═══ MAIN APP ═══ -->
  <div class="app">

    <!-- Navigation -->
    <div class="nav">
      <button class="nav-tab active" data-page="speedreader" type="button">SpeedReader</button>
      <button class="nav-tab" data-page="voicereader" type="button">VoiceReader</button>
      <button class="nav-tab" data-page="comboreader" type="button">ComboReader</button>
    </div>

    <!-- ═══ PAGE 1: SPEED READER ═══ -->
    <div class="page active" id="page-speedreader">
      <div class="top">
        <div class="brand"><span class="red">Speed</span>Reader</div>

        <div class="controls">
          <div class="speed" aria-label="Speed">
            <button data-wpm="250" type="button">250 WPM</button>
            <button data-wpm="400" class="active" type="button">400 WPM</button>
            <button data-wpm="900" type="button">900 WPM</button>
          </div>

          <button id="playPause" class="primary" type="button" disabled>Play</button>
          <button id="reset" type="button" disabled>Reset</button>
        </div>
      </div>

      <div class="drop" id="drop" role="button" tabindex="0" aria-label="Upload PDF">
        <div class="t">Upload PDF here</div>
        <div class="s">Click or drag & drop</div>
        <div class="fn" id="fileName"></div>
      </div>
      <input type="file" id="file" accept="application/pdf">

      <div class="reader">
        <div class="guide"></div>
        <div class="word" id="word">—</div>
      </div>

      <div class="status">
        <div id="left">No PDF loaded.</div>
        <div id="right"></div>
      </div>
    </div>

    <!-- ═══ PAGE 2: VOICE READER ═══ -->
    <div class="page" id="page-voicereader">
      <div class="top">
        <div class="brand"><span class="red">Voice</span>Reader</div>
      </div>

      <div class="drop" id="vrDrop" role="button" tabindex="0" aria-label="Upload PDF">
        <div class="t">Upload PDF here</div>
        <div class="s">Click or drag & drop</div>
        <div class="fn" id="vrFileName"></div>
      </div>
      <input type="file" id="vrFile" accept="application/pdf">

      <div class="vr-settings">
        <div class="vr-field">
          <label for="vrVoice">Voice</label>
          <select id="vrVoice">
            <option value="">Loading voices…</option>
          </select>
        </div>
        <div class="vr-field" style="min-width:100px;flex:0.4">
          <label for="vrSpeed">Speed</label>
          <select id="vrSpeed">
            <option value="1" selected>1×</option>
            <option value="1.5">1.5×</option>
            <option value="2">2×</option>
          </select>
        </div>
        <button id="vrPreview" type="button" style="align-self:end" disabled>Preview Voice</button>
      </div>

      <div class="vr-controls">
        <button id="vrPlay" class="primary" type="button" disabled>Play</button>
        <button id="vrPauseResume" type="button" disabled>Pause</button>
        <button id="vrStop" type="button" disabled>Stop</button>
      </div>

      <div class="vr-text-area" id="vrTextArea">
        <span class="empty-msg">Upload a PDF to see text here.</span>
      </div>

      <div class="vr-progress">
        <span id="vrProgressLabel">0%</span>
        <div class="vr-progress-bar">
          <div class="vr-progress-fill" id="vrProgressFill"></div>
        </div>
      </div>

      <div class="status">
        <div id="vrLeft">No PDF loaded.</div>
        <div id="vrRight"></div>
      </div>
    </div>

    <!-- ═══ PAGE 3: COMBO READER ═══ -->
    <div class="page" id="page-comboreader">
      <div class="top">
        <div class="brand"><span class="red">Combo</span>Reader</div>
      </div>

      <div class="drop" id="crDrop" role="button" tabindex="0" aria-label="Upload PDF">
        <div class="t">Upload PDF here</div>
        <div class="s">Click or drag & drop</div>
        <div class="fn" id="crFileName"></div>
      </div>
      <input type="file" id="crFile" accept="application/pdf">

      <div class="vr-settings">
        <div class="vr-field">
          <label for="crVoice">Voice</label>
          <select id="crVoice">
            <option value="">Loading voices…</option>
          </select>
        </div>
        <div class="vr-field" style="min-width:100px;flex:0.4">
          <label for="crSpeed">Speed</label>
          <select id="crSpeed">
            <option value="1" selected>1×</option>
            <option value="1.5">1.5×</option>
            <option value="2">2×</option>
          </select>
        </div>
        <button id="crPreview" type="button" style="align-self:end" disabled>Preview Voice</button>
      </div>

      <div class="vr-controls">
        <button id="crPlay" class="primary" type="button" disabled>Play</button>
        <button id="crPauseResume" type="button" disabled>Pause</button>
        <button id="crStop" type="button" disabled>Stop</button>
      </div>

      <div class="reader">
        <div class="guide"></div>
        <div class="word" id="crWord">—</div>
      </div>

      <div class="vr-progress">
        <span id="crProgressLabel">0%</span>
        <div class="vr-progress-bar">
          <div class="vr-progress-fill" id="crProgressFill"></div>
        </div>
      </div>

      <div class="status">
        <div id="crLeft">No PDF loaded.</div>
        <div id="crRight"></div>
      </div>
    </div>
  </div>

  <!-- ═══ BOTTOM AD BANNER ═══ -->
  <div class="ad-banner bottom">
    <!-- AdSense responsive ad unit (bottom) -->
    <ins class="adsbygoogle"
      style="display:block;width:100%;min-height:90px"
      data-ad-client="ca-pub-3128443998439992"
      data-ad-slot="BOTTOM_AD_SLOT_ID"
      data-ad-format="horizontal"
      data-full-width-responsive="true"></ins>
    <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>

    <!-- Placeholder shown when ads aren't loaded yet -->
    <div class="ad-placeholder" id="adPlaceholderBottom">
      <div class="ad-scroll">
        <div class="ad-scroll-item">Ad Space — Google AdSense</div>
        <div class="ad-scroll-item">Your ad could appear here</div>
        <div class="ad-scroll-item">Ads will appear here once your AdSense account is approved</div>
        <div class="ad-scroll-item">Ad Space — Google AdSense</div>
        <div class="ad-scroll-item">Your ad could appear here</div>
        <div class="ad-scroll-item">Ads will appear here once your AdSense account is approved</div>
      </div>
    </div>
  </div>

  <!-- Stable PDF.js UMD build -->
  <script src="https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js"></script>

  <script>
    // ================================================================
    //  NAVIGATION
    // ================================================================
    const navTabs = document.querySelectorAll('.nav-tab');
    const pages = document.querySelectorAll('.page');

    navTabs.forEach(tab => {
      tab.onclick = () => {
        navTabs.forEach(t => t.classList.remove('active'));
        pages.forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById('page-' + tab.dataset.page).classList.add('active');
      };
    });

    // ================================================================
    //  AD PLACEHOLDER VISIBILITY
    //  Hides the scrolling placeholder text once real ads load.
    // ================================================================
    (function hideAdPlaceholders(){
      setTimeout(() => {
        document.querySelectorAll('.ad-banner').forEach(banner => {
          const ins = banner.querySelector('ins.adsbygoogle');
          if (ins && ins.children.length > 0) {
            const ph = banner.querySelector('.ad-placeholder');
            if (ph) ph.style.display = 'none';
          }
        });
      }, 3000);
    })();

    // ================================================================
    //  SPEED READER (unchanged logic)
    // ================================================================
    pdfjsLib.GlobalWorkerOptions.workerSrc = null;

    const drop = document.getElementById("drop");
    const fileInput = document.getElementById("file");
    const fileNameEl = document.getElementById("fileName");

    const wordEl = document.getElementById("word");
    const leftEl = document.getElementById("left");
    const rightEl = document.getElementById("right");

    const playPauseBtn = document.getElementById("playPause");
    const resetBtn = document.getElementById("reset");

    const speedBtns = Array.from(document.querySelectorAll("#page-speedreader .speed button"));

    let words = [];
    let idx = 0;
    let wpm = 400;
    let timer = null;
    let playing = false;

    function msPerWord(){ return 60000 / wpm; }

    function tokenize(text){
      return text.split(/\s+/).filter(Boolean);
    }

    function centerIndex(len){
      return Math.floor((len - 1) / 2);
    }

    function splitPunctuation(raw){
      const m = raw.match(/^([("'\[{<]*)(.*?)([)\\"'\]}>,.!?:;]*)$/);
      if (!m) return { lead:"", core:raw, tail:"" };
      return { lead:m[1]||"", core:m[2]||"", tail:m[3]||"" };
    }

    function escapeHtml(s){
      return s
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function renderWord(raw){
      if (!raw){ wordEl.textContent = "—"; return; }

      const {lead, core, tail} = splitPunctuation(raw);
      if (!core){ wordEl.textContent = raw; return; }

      const i = centerIndex(core.length);
      const before = core.slice(0,i);
      const mid = core[i];
      const after = core.slice(i+1);

      wordEl.innerHTML =
        `${escapeHtml(lead)}${escapeHtml(before)}<span class="orp">${escapeHtml(mid)}</span>${escapeHtml(after)}${escapeHtml(tail)}`;
    }

    function updateStatus(){
      if (!words.length){
        leftEl.textContent = "No PDF loaded.";
        rightEl.textContent = "";
        return;
      }
      leftEl.textContent = `Loaded: ${words.length.toLocaleString()} words`;
      rightEl.textContent = `${Math.min(idx, words.length).toLocaleString()}/${words.length.toLocaleString()}`;
    }

    function stop(){
      playing = false;
      playPauseBtn.textContent = "Play";
      if (timer){ clearTimeout(timer); timer = null; }
    }

    function scheduleNext(){
      if (!playing) return;

      if (idx >= words.length){
        stop();
        renderWord("Done.");
        return;
      }

      renderWord(words[idx]);
      idx++;
      updateStatus();

      timer = setTimeout(scheduleNext, msPerWord());
    }

    function play(){
      if (!words.length) return;
      playing = true;
      playPauseBtn.textContent = "Pause";
      if (timer){ clearTimeout(timer); timer = null; }
      scheduleNext();
    }

    function togglePlayPause(){
      if (!words.length) return;
      if (playing) stop();
      else play();
    }

    function srReset(){
      stop();
      idx = 0;
      renderWord(words[0] || "—");
      updateStatus();
    }

    // Upload
    drop.onclick = () => fileInput.click();
    drop.onkeydown = (e) => { if (e.key === "Enter" || e.key === " ") fileInput.click(); };

    drop.ondragover = (e) => { e.preventDefault(); };
    drop.ondrop = (e) => {
      e.preventDefault();
      const f = e.dataTransfer.files?.[0];
      if (f && f.type === "application/pdf") loadPdf(f);
    };

    fileInput.onchange = () => {
      const f = fileInput.files?.[0];
      if (f) loadPdf(f);
      fileInput.value = "";
    };

    async function loadPdf(file){
      stop();
      renderWord("…");
      leftEl.textContent = "Reading PDF…";
      rightEl.textContent = "";

      fileNameEl.textContent = file.name;

      try{
        const buf = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: buf }).promise;

        let text = "";
        for (let p = 1; p <= pdf.numPages; p++){
          const page = await pdf.getPage(p);
          const c = await page.getTextContent();
          text += c.items.map(x => x.str).join(" ") + " ";
        }

        words = tokenize(text);
        idx = 0;

        if (!words.length){
          renderWord("No text found.");
          leftEl.textContent = "No extractable text found in this PDF.";
          rightEl.textContent = "If scanned, OCR is required.";
          playPauseBtn.disabled = true;
          resetBtn.disabled = true;
          return;
        }

        renderWord(words[0]);
        updateStatus();
        playPauseBtn.disabled = false;
        resetBtn.disabled = false;

      } catch (err){
        console.error(err);
        renderWord("Error.");
        leftEl.textContent = "Failed to read PDF.";
        rightEl.textContent = "See console.";
        playPauseBtn.disabled = true;
        resetBtn.disabled = true;
      }
    }

    // Speed controls
    speedBtns.forEach(btn => {
      btn.onclick = () => {
        speedBtns.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        wpm = Number(btn.dataset.wpm);

        if (playing){
          if (timer){ clearTimeout(timer); timer = null; }
          scheduleNext();
        }
      };
    });

    playPauseBtn.onclick = togglePlayPause;
    resetBtn.onclick = srReset;

    renderWord("—");
    updateStatus();

    // ================================================================
    //  VOICE READER
    // ================================================================
    const vrDrop = document.getElementById("vrDrop");
    const vrFileInput = document.getElementById("vrFile");
    const vrFileNameEl = document.getElementById("vrFileName");
    const vrVoiceSelect = document.getElementById("vrVoice");
    const vrSpeedSelect = document.getElementById("vrSpeed");
    const vrPreviewBtn = document.getElementById("vrPreview");
    const vrPlayBtn = document.getElementById("vrPlay");
    const vrPauseResumeBtn = document.getElementById("vrPauseResume");
    const vrStopBtn = document.getElementById("vrStop");
    const vrTextArea = document.getElementById("vrTextArea");
    const vrLeftEl = document.getElementById("vrLeft");
    const vrRightEl = document.getElementById("vrRight");
    const vrProgressLabel = document.getElementById("vrProgressLabel");
    const vrProgressFill = document.getElementById("vrProgressFill");

    let vrText = "";
    let vrWords = [];
    let vrUtterance = null;
    let vrIsSpeaking = false;
    let vrIsPaused = false;
    let vrCurrentCharIndex = 0;

    // ── Voice loading ──
    // Quality voice name substrings — these tend to be the premium/natural voices
    const qualityVoicePatterns = [
      "Google", "Microsoft", "Samantha", "Daniel", "Karen", "Moira",
      "Tessa", "Fiona", "Alex", "Victoria", "Zarvox", "Enhanced",
      "Premium", "Natural", "Neural", "Online", "Compact"
    ];

    // Known low-quality / novelty voices to exclude
    const excludePatterns = [
      "Zarvox", "Trinoids", "Whisper", "Bells", "Boing",
      "Bad News", "Good News", "Bubbles", "Cellos", "Pipe Organ"
    ];

    let allVoices = [];

    function isHighQuality(voice) {
      const name = voice.name;
      if (excludePatterns.some(p => name.includes(p))) return false;
      if (qualityVoicePatterns.some(p => name.includes(p))) return true;
      if (!voice.localService) return true;
      return false;
    }

    // ── Friendly voice name mapping ──
    const langNames = {
      'en-GB': 'English (UK)', 'en-US': 'English (US)', 'en-AU': 'English (AU)',
      'en-IN': 'English (India)', 'en': 'English',
      'de-DE': 'German', 'de': 'German',
      'fr-FR': 'French', 'fr-CA': 'French (Canada)', 'fr': 'French',
      'es-ES': 'Spanish (Spain)', 'es-US': 'Spanish (US)', 'es-MX': 'Spanish (Mexico)', 'es': 'Spanish',
      'it-IT': 'Italian', 'it': 'Italian',
      'pt-BR': 'Portuguese (Brazil)', 'pt-PT': 'Portuguese', 'pt': 'Portuguese',
      'nl-NL': 'Dutch', 'nl': 'Dutch',
      'pl-PL': 'Polish', 'pl': 'Polish',
      'ru-RU': 'Russian', 'ru': 'Russian',
      'ja-JP': 'Japanese', 'ja': 'Japanese',
      'ko-KR': 'Korean', 'ko': 'Korean',
      'zh-CN': 'Chinese (Simplified)', 'zh-TW': 'Chinese (Traditional)', 'zh': 'Chinese',
      'hi-IN': 'Hindi', 'hi': 'Hindi',
      'id-ID': 'Indonesian', 'id': 'Indonesian',
      'nb-NO': 'Norwegian', 'no': 'Norwegian',
      'sv-SE': 'Swedish', 'sv': 'Swedish',
      'da-DK': 'Danish', 'da': 'Danish',
      'fi-FI': 'Finnish', 'fi': 'Finnish',
      'tr-TR': 'Turkish', 'tr': 'Turkish',
      'ar-SA': 'Arabic', 'ar': 'Arabic',
      'th-TH': 'Thai', 'th': 'Thai',
      'vi-VN': 'Vietnamese', 'vi': 'Vietnamese',
    };

    function friendlyVoiceName(voice) {
      const name = voice.name;
      const lang = langNames[voice.lang] || langNames[voice.lang.split('-')[0]] || voice.lang;

      // Google voices: "Google UK English Female" → "Female English (UK)"
      const googleMatch = name.match(/^Google\s+(?:UK\s+)?(?:US\s+)?(.+?)$/i);
      if (googleMatch) {
        const part = googleMatch[1];
        // "UK English Female" → "Female English (UK)"
        if (name.includes('Female')) return `Female — ${lang}`;
        if (name.includes('Male')) return `Male — ${lang}`;
        // Non-English Google voices: "Google Deutsch" → "German"
        return lang;
      }

      // Microsoft voices: "Microsoft David - English (United States)" → "David — Male English (US)"
      const msMatch = name.match(/^Microsoft\s+(\w+)\s*-\s*(.+)$/i);
      if (msMatch) {
        const person = msMatch[1];
        const knownMale = ['David', 'Mark', 'George', 'Richard', 'James', 'Sean'];
        const knownFemale = ['Zira', 'Hazel', 'Susan', 'Catherine', 'Linda', 'Jenny'];
        let gender = '';
        if (knownMale.includes(person)) gender = 'Male';
        else if (knownFemale.includes(person)) gender = 'Female';
        return `${person}${gender ? ' — ' + gender : ''} — ${lang}`;
      }

      // Apple/other voices: "Samantha", "Daniel", etc.
      const knownAppleFemale = ['Samantha', 'Karen', 'Moira', 'Tessa', 'Fiona', 'Victoria', 'Allison', 'Ava'];
      const knownAppleMale = ['Daniel', 'Alex', 'Tom', 'Oliver', 'Fred', 'Ralph'];
      for (const n of knownAppleFemale) {
        if (name.includes(n)) return `${n} — Female — ${lang}`;
      }
      for (const n of knownAppleMale) {
        if (name.includes(n)) return `${n} — Male — ${lang}`;
      }

      // Fallback: just show name + language
      return `${name} — ${lang}`;
    }

    function loadVoices() {
      allVoices = speechSynthesis.getVoices();
      if (!allVoices.length) return;

      let filtered = allVoices.filter(isHighQuality);
      // Fallback: if no "high quality" voices found, show all English voices
      if (!filtered.length) {
        filtered = allVoices.filter(v => v.lang.startsWith("en"));
      }
      // Last resort: show everything
      if (!filtered.length) filtered = allVoices;

      // Sort: English first, then alphabetical
      filtered.sort((a, b) => {
        const aEn = a.lang.startsWith("en") ? 0 : 1;
        const bEn = b.lang.startsWith("en") ? 0 : 1;
        if (aEn !== bEn) return aEn - bEn;
        return a.name.localeCompare(b.name);
      });

      vrVoiceSelect.innerHTML = "";
      filtered.forEach((v, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.textContent = friendlyVoiceName(v);
        vrVoiceSelect.appendChild(opt);
      });

      // Store filtered list for lookup
      vrVoiceSelect._voices = filtered;
      vrPreviewBtn.disabled = false;
    }

    speechSynthesis.onvoiceschanged = loadVoices;
    loadVoices(); // some browsers populate synchronously

    function getSelectedVoice() {
      const voices = vrVoiceSelect._voices;
      if (!voices || !voices.length) return null;
      return voices[vrVoiceSelect.selectedIndex] || voices[0];
    }

    // ── Preview ──
    vrPreviewBtn.onclick = () => {
      speechSynthesis.cancel();
      const voice = getSelectedVoice();
      if (!voice) return;

      const sample = new SpeechSynthesisUtterance(
        "The quick brown fox jumps over the lazy dog. This is a preview of the selected voice."
      );
      sample.voice = voice;
      sample.rate = parseFloat(vrSpeedSelect.value);
      speechSynthesis.speak(sample);
    };

    // ── PDF upload (VoiceReader) ──
    vrDrop.onclick = () => vrFileInput.click();
    vrDrop.onkeydown = (e) => { if (e.key === "Enter" || e.key === " ") vrFileInput.click(); };
    vrDrop.ondragover = (e) => e.preventDefault();
    vrDrop.ondrop = (e) => {
      e.preventDefault();
      const f = e.dataTransfer.files?.[0];
      if (f && f.type === "application/pdf") vrLoadPdf(f);
    };
    vrFileInput.onchange = () => {
      const f = vrFileInput.files?.[0];
      if (f) vrLoadPdf(f);
      vrFileInput.value = "";
    };

    async function vrLoadPdf(file) {
      speechSynthesis.cancel();
      vrResetState();

      vrFileNameEl.textContent = file.name;
      vrLeftEl.textContent = "Reading PDF…";
      vrTextArea.innerHTML = '<span class="empty-msg">Reading PDF…</span>';

      try {
        const buf = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: buf }).promise;

        let text = "";
        for (let p = 1; p <= pdf.numPages; p++) {
          const page = await pdf.getPage(p);
          const c = await page.getTextContent();
          text += c.items.map(x => x.str).join(" ") + " ";
        }

        vrText = text.trim();
        vrWords = tokenize(vrText);

        if (!vrWords.length) {
          vrLeftEl.textContent = "No extractable text found.";
          vrTextArea.innerHTML = '<span class="empty-msg">No text found in PDF. If scanned, OCR is needed.</span>';
          return;
        }

        vrLeftEl.textContent = `Loaded: ${vrWords.length.toLocaleString()} words`;
        vrRightEl.textContent = "";

        // Show full text in the text area
        vrRenderText(-1);

        vrPlayBtn.disabled = false;

      } catch (err) {
        console.error(err);
        vrLeftEl.textContent = "Failed to read PDF.";
        vrTextArea.innerHTML = '<span class="empty-msg">Error reading PDF. See console.</span>';
      }
    }

    function vrResetState() {
      vrIsSpeaking = false;
      vrIsPaused = false;
      vrCurrentCharIndex = 0;
      vrPlayBtn.textContent = "Play";
      vrPlayBtn.disabled = true;
      vrPauseResumeBtn.disabled = true;
      vrStopBtn.disabled = true;
      vrProgressFill.style.width = "0%";
      vrProgressLabel.textContent = "0%";
      vrRightEl.textContent = "";
    }

    // ── Render text with highlighting ──
    function vrRenderText(charIndex) {
      if (!vrText) return;

      if (charIndex < 0) {
        vrTextArea.textContent = vrText;
        return;
      }

      // Find word boundary around charIndex
      let wordStart = charIndex;
      let wordEnd = charIndex;
      while (wordStart > 0 && vrText[wordStart - 1] !== ' ') wordStart--;
      while (wordEnd < vrText.length && vrText[wordEnd] !== ' ') wordEnd++;

      const before = vrText.slice(0, wordStart);
      const current = vrText.slice(wordStart, wordEnd);
      const after = vrText.slice(wordEnd);

      vrTextArea.innerHTML =
        `<span class="spoken">${escapeHtml(before)}</span><span class="current-word">${escapeHtml(current)}</span>${escapeHtml(after)}`;

      // Auto-scroll to keep current word visible
      const currentEl = vrTextArea.querySelector('.current-word');
      if (currentEl) {
        const areaRect = vrTextArea.getBoundingClientRect();
        const wordRect = currentEl.getBoundingClientRect();
        if (wordRect.top < areaRect.top || wordRect.bottom > areaRect.bottom) {
          currentEl.scrollIntoView({ block: 'center', behavior: 'smooth' });
        }
      }

      // Update progress
      const pct = Math.min(100, Math.round((charIndex / vrText.length) * 100));
      vrProgressFill.style.width = pct + "%";
      vrProgressLabel.textContent = pct + "%";
    }

    // ── Chunked speech (Chrome silently fails on long text) ──
    let vrChunks = [];
    let vrChunkIndex = 0;
    let vrChunkCharOffset = 0; // tracks character offset into full text

    function splitIntoChunks(text, maxLen) {
      const chunks = [];
      let start = 0;
      while (start < text.length) {
        let end = Math.min(start + maxLen, text.length);
        // Try to break at sentence boundary
        if (end < text.length) {
          const slice = text.slice(start, end);
          const lastPeriod = slice.lastIndexOf('. ');
          const lastQuestion = slice.lastIndexOf('? ');
          const lastExclaim = slice.lastIndexOf('! ');
          const best = Math.max(lastPeriod, lastQuestion, lastExclaim);
          if (best > maxLen * 0.3) {
            end = start + best + 2;
          }
        }
        chunks.push({ text: text.slice(start, end), offset: start });
        start = end;
      }
      return chunks;
    }

    function vrSpeakChunk() {
      if (vrChunkIndex >= vrChunks.length) {
        vrIsSpeaking = false;
        vrIsPaused = false;
        vrPlayBtn.textContent = "Play";
        vrPlayBtn.disabled = false;
        vrPauseResumeBtn.disabled = true;
        vrStopBtn.disabled = true;
        vrProgressFill.style.width = "100%";
        vrProgressLabel.textContent = "100%";
        vrRightEl.textContent = "Done.";
        return;
      }

      const chunk = vrChunks[vrChunkIndex];
      vrChunkCharOffset = chunk.offset;

      vrUtterance = new SpeechSynthesisUtterance(chunk.text);
      vrUtterance.voice = getSelectedVoice();
      vrUtterance.rate = parseFloat(vrSpeedSelect.value);

      vrUtterance.onboundary = (e) => {
        if (e.name === 'word') {
          const globalIndex = vrChunkCharOffset + e.charIndex;
          vrCurrentCharIndex = globalIndex;
          vrRenderText(globalIndex);
        }
      };

      vrUtterance.onend = () => {
        vrChunkIndex++;
        if (vrIsSpeaking && !vrIsPaused) {
          vrSpeakChunk();
        }
      };

      vrUtterance.onerror = (e) => {
        if (e.error === 'canceled') return;
        console.error("Speech error:", e);
        vrRightEl.textContent = "Speech error. See console.";
        vrIsSpeaking = false;
      };

      speechSynthesis.speak(vrUtterance);
    }

    // ── Speech controls ──
    vrPlayBtn.onclick = () => {
      if (vrIsSpeaking && !vrIsPaused) return;
      if (vrIsPaused) {
        speechSynthesis.resume();
        vrIsPaused = false;
        vrPauseResumeBtn.textContent = "Pause";
        vrPlayBtn.textContent = "Playing…";
        return;
      }

      const voice = getSelectedVoice();
      if (!voice || !vrText) return;

      speechSynthesis.cancel();

      // Split text into ~2000 char chunks at sentence boundaries
      vrChunks = splitIntoChunks(vrText, 2000);
      vrChunkIndex = 0;

      vrIsSpeaking = true;
      vrIsPaused = false;
      vrPlayBtn.textContent = "Playing…";
      vrPauseResumeBtn.textContent = "Pause";
      vrPauseResumeBtn.disabled = false;
      vrStopBtn.disabled = false;
      vrRightEl.textContent = "";

      vrSpeakChunk();
    };

    // Restart speech at new speed when changed mid-playback
    vrSpeedSelect.onchange = () => {
      if (vrIsSpeaking && !vrIsPaused) {
        speechSynthesis.cancel();
        vrSpeakChunk(); // restart current chunk at new rate
      }
    };

    vrPauseResumeBtn.onclick = () => {
      if (!vrIsSpeaking) return;
      if (vrIsPaused) {
        speechSynthesis.resume();
        vrIsPaused = false;
        vrPauseResumeBtn.textContent = "Pause";
        vrPlayBtn.textContent = "Playing…";
      } else {
        speechSynthesis.pause();
        vrIsPaused = true;
        vrPauseResumeBtn.textContent = "Resume";
        vrPlayBtn.textContent = "Paused";
      }
    };

    vrStopBtn.onclick = () => {
      speechSynthesis.cancel();
      vrIsSpeaking = false;
      vrIsPaused = false;
      vrChunks = [];
      vrChunkIndex = 0;
      vrPlayBtn.textContent = "Play";
      vrPlayBtn.disabled = false;
      vrPauseResumeBtn.disabled = true;
      vrStopBtn.disabled = true;
      if (vrText) vrRenderText(-1);
      vrProgressFill.style.width = "0%";
      vrProgressLabel.textContent = "0%";
    };

    // ── Keep speech synthesis alive (Chrome pauses after ~15s) ──
    setInterval(() => {
      if (vrIsSpeaking && !vrIsPaused) {
        speechSynthesis.pause();
        speechSynthesis.resume();
      }
      if (crIsSpeaking && !crIsPaused) {
        speechSynthesis.pause();
        speechSynthesis.resume();
      }
    }, 10000);

    // ================================================================
    //  COMBO READER (SpeedReader display + VoiceReader audio synced)
    // ================================================================
    const crDrop = document.getElementById("crDrop");
    const crFileInput = document.getElementById("crFile");
    const crFileNameEl = document.getElementById("crFileName");
    const crVoiceSelect = document.getElementById("crVoice");
    const crSpeedSelect = document.getElementById("crSpeed");
    const crPreviewBtn = document.getElementById("crPreview");
    const crPlayBtn = document.getElementById("crPlay");
    const crPauseResumeBtn = document.getElementById("crPauseResume");
    const crStopBtn = document.getElementById("crStop");
    const crWordEl = document.getElementById("crWord");
    const crLeftEl = document.getElementById("crLeft");
    const crRightEl = document.getElementById("crRight");
    const crProgressLabel = document.getElementById("crProgressLabel");
    const crProgressFill = document.getElementById("crProgressFill");

    let crText = "";
    let crWords = [];
    let crIsSpeaking = false;
    let crIsPaused = false;
    let crChunks = [];
    let crChunkIndex = 0;
    let crWordIdx = 0;
    let crWordTimer = null;
    let crPausedAtWord = 0;

    // ── Populate voice dropdown (reuse same filter logic) ──
    function crLoadVoices() {
      const voices = speechSynthesis.getVoices();
      if (!voices.length) return;

      let filtered = voices.filter(isHighQuality);
      if (!filtered.length) filtered = voices.filter(v => v.lang.startsWith("en"));
      if (!filtered.length) filtered = voices;

      filtered.sort((a, b) => {
        const aEn = a.lang.startsWith("en") ? 0 : 1;
        const bEn = b.lang.startsWith("en") ? 0 : 1;
        if (aEn !== bEn) return aEn - bEn;
        return a.name.localeCompare(b.name);
      });

      crVoiceSelect.innerHTML = "";
      filtered.forEach((v, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.textContent = friendlyVoiceName(v);
        crVoiceSelect.appendChild(opt);
      });
      crVoiceSelect._voices = filtered;
      crPreviewBtn.disabled = false;
    }

    speechSynthesis.addEventListener('voiceschanged', crLoadVoices);
    crLoadVoices();

    function crGetSelectedVoice() {
      const voices = crVoiceSelect._voices;
      if (!voices || !voices.length) return null;
      return voices[crVoiceSelect.selectedIndex] || voices[0];
    }

    // ── Render word with ORP (reuse SpeedReader's logic) ──
    function crRenderWord(raw) {
      if (!raw) { crWordEl.textContent = "—"; return; }
      const {lead, core, tail} = splitPunctuation(raw);
      if (!core) { crWordEl.textContent = raw; return; }
      const i = centerIndex(core.length);
      const before = core.slice(0, i);
      const mid = core[i];
      const after = core.slice(i + 1);
      crWordEl.innerHTML =
        `${escapeHtml(lead)}${escapeHtml(before)}<span class="orp">${escapeHtml(mid)}</span>${escapeHtml(after)}${escapeHtml(tail)}`;
    }

    // ── Preview ──
    crPreviewBtn.onclick = () => {
      speechSynthesis.cancel();
      const voice = crGetSelectedVoice();
      if (!voice) return;
      const sample = new SpeechSynthesisUtterance(
        "The quick brown fox jumps over the lazy dog. This is a preview of the selected voice."
      );
      sample.voice = voice;
      sample.rate = parseFloat(crSpeedSelect.value);
      speechSynthesis.speak(sample);
    };

    // ── PDF upload ──
    crDrop.onclick = () => crFileInput.click();
    crDrop.onkeydown = (e) => { if (e.key === "Enter" || e.key === " ") crFileInput.click(); };
    crDrop.ondragover = (e) => e.preventDefault();
    crDrop.ondrop = (e) => {
      e.preventDefault();
      const f = e.dataTransfer.files?.[0];
      if (f && f.type === "application/pdf") crLoadPdf(f);
    };
    crFileInput.onchange = () => {
      const f = crFileInput.files?.[0];
      if (f) crLoadPdf(f);
      crFileInput.value = "";
    };

    async function crLoadPdf(file) {
      speechSynthesis.cancel();
      crResetState();
      crFileNameEl.textContent = file.name;
      crLeftEl.textContent = "Reading PDF…";

      try {
        const buf = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
        let text = "";
        for (let p = 1; p <= pdf.numPages; p++) {
          const page = await pdf.getPage(p);
          const c = await page.getTextContent();
          text += c.items.map(x => x.str).join(" ") + " ";
        }
        crText = text.trim();
        crWords = tokenize(crText);

        if (!crWords.length) {
          crLeftEl.textContent = "No extractable text found.";
          crRenderWord("No text.");
          return;
        }

        crLeftEl.textContent = `Loaded: ${crWords.length.toLocaleString()} words`;
        crRenderWord(crWords[0]);
        crPlayBtn.disabled = false;
      } catch (err) {
        console.error(err);
        crLeftEl.textContent = "Failed to read PDF.";
        crRenderWord("Error.");
      }
    }

    function crResetState() {
      crIsSpeaking = false;
      crIsPaused = false;
      crWordIdx = 0;
      crPausedAtWord = 0;
      if (crWordTimer) { clearTimeout(crWordTimer); crWordTimer = null; }
      crPlayBtn.textContent = "Play";
      crPlayBtn.disabled = true;
      crPauseResumeBtn.disabled = true;
      crStopBtn.disabled = true;
      crProgressFill.style.width = "0%";
      crProgressLabel.textContent = "0%";
      crRightEl.textContent = "";
      crRenderWord("—");
    }

    // ── Flowing chunk speech + timer-synced word display ──
    // Speech plays in natural chunks (smooth audio).
    // Word display advances on a timer estimated from speech rate.
    // At rate 1.0 ≈ 160 WPM (375ms/word), adjusted by word length.
    function crMsForWord(word) {
      const rate = parseFloat(crSpeedSelect.value) || 1;
      const baseMs = 375 / rate;
      const len = word.length;
      if (len <= 2) return baseMs * 0.6;
      if (len <= 4) return baseMs * 0.8;
      if (len <= 7) return baseMs;
      if (len <= 10) return baseMs * 1.2;
      return baseMs * 1.4;
    }

    function crAdvanceWord() {
      if (!crIsSpeaking || crIsPaused) return;

      if (crWordIdx >= crWords.length) {
        crIsSpeaking = false;
        if (crWordTimer) { clearTimeout(crWordTimer); crWordTimer = null; }
        crPlayBtn.textContent = "Play";
        crPlayBtn.disabled = false;
        crPauseResumeBtn.disabled = true;
        crStopBtn.disabled = true;
        crProgressFill.style.width = "100%";
        crProgressLabel.textContent = "100%";
        crRightEl.textContent = "Done.";
        crRenderWord("Done.");
        return;
      }

      const word = crWords[crWordIdx];
      crRenderWord(word);
      crWordIdx++;

      crRightEl.textContent = `${crWordIdx.toLocaleString()}/${crWords.length.toLocaleString()}`;
      const pct = Math.min(100, Math.round((crWordIdx / crWords.length) * 100));
      crProgressFill.style.width = pct + "%";
      crProgressLabel.textContent = pct + "%";

      crWordTimer = setTimeout(crAdvanceWord, crMsForWord(word));
    }

    // Chunk-based speech for natural flowing audio
    function crSpeakFromWord(startWordIdx) {
      // Build text from startWordIdx onward
      const remaining = crWords.slice(startWordIdx).join(' ');
      crChunks = splitIntoChunks(remaining, 2000);
      crChunkIndex = 0;
      crSpeakChunk();
    }

    function crSpeakChunk() {
      if (crChunkIndex >= crChunks.length) return;

      const chunk = crChunks[crChunkIndex];
      const utt = new SpeechSynthesisUtterance(chunk.text);
      utt.voice = crGetSelectedVoice();
      utt.rate = parseFloat(crSpeedSelect.value) || 1;

      utt.onend = () => {
        crChunkIndex++;
        if (crIsSpeaking && !crIsPaused && crChunkIndex < crChunks.length) {
          crSpeakChunk();
        }
      };

      utt.onerror = (e) => {
        if (e.error === 'canceled') return;
        console.error("Combo speech error:", e);
      };

      speechSynthesis.speak(utt);
    }

    // ── Controls ──
    crPlayBtn.onclick = () => {
      if (crIsSpeaking && !crIsPaused) return;
      if (crIsPaused) {
        // Resume from where we paused
        crIsPaused = false;
        crWordIdx = crPausedAtWord;
        crPauseResumeBtn.textContent = "Pause";
        crPlayBtn.textContent = "Playing…";
        crSpeakFromWord(crWordIdx);
        crAdvanceWord();
        return;
      }

      const voice = crGetSelectedVoice();
      if (!voice || !crText) return;

      speechSynthesis.cancel();
      crWordIdx = 0;

      crIsSpeaking = true;
      crIsPaused = false;
      crPlayBtn.textContent = "Playing…";
      crPauseResumeBtn.textContent = "Pause";
      crPauseResumeBtn.disabled = false;
      crStopBtn.disabled = false;
      crRightEl.textContent = "";

      crSpeakFromWord(0);
      crAdvanceWord();
    };

    // Speed change restarts both speech and timer from current word
    crSpeedSelect.onchange = () => {
      if (crIsSpeaking && !crIsPaused) {
        speechSynthesis.cancel();
        if (crWordTimer) { clearTimeout(crWordTimer); crWordTimer = null; }
        crSpeakFromWord(crWordIdx);
        crAdvanceWord();
      }
    };

    crPauseResumeBtn.onclick = () => {
      if (!crIsSpeaking) return;
      if (crIsPaused) {
        crIsPaused = false;
        crWordIdx = crPausedAtWord;
        crPauseResumeBtn.textContent = "Pause";
        crPlayBtn.textContent = "Playing…";
        crSpeakFromWord(crWordIdx);
        crAdvanceWord();
      } else {
        speechSynthesis.cancel();
        if (crWordTimer) { clearTimeout(crWordTimer); crWordTimer = null; }
        crIsPaused = true;
        crPausedAtWord = crWordIdx;
        crPauseResumeBtn.textContent = "Resume";
        crPlayBtn.textContent = "Paused";
      }
    };

    crStopBtn.onclick = () => {
      speechSynthesis.cancel();
      if (crWordTimer) { clearTimeout(crWordTimer); crWordTimer = null; }
      crIsSpeaking = false;
      crIsPaused = false;
      crWordIdx = 0;
      crPausedAtWord = 0;
      crPlayBtn.textContent = "Play";
      crPlayBtn.disabled = false;
      crPauseResumeBtn.disabled = true;
      crStopBtn.disabled = true;
      crRenderWord(crWords[0] || "—");
      crProgressFill.style.width = "0%";
      crProgressLabel.textContent = "0%";
      crRightEl.textContent = "";
    };

  </script>
</body>
</html>
